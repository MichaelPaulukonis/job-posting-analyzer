# Analysis History Synchronization Plan

## Problem Statement
The `/analyze` page flashes outdated five-item history lists sourced from stale `localStorage`, even though the Admin interface reads the latest `.data/analysis-history.json`. Selecting older entries can crash because legacy records lack `jobPosting` or `resume` payloads. We need consistent, resilient history loading that prioritizes server truth, keeps the local cache in sync, and gracefully handles incomplete legacy data.

## Requirements
1. **Server Source of Truth**: Storage logic must always attempt server fetches first and treat local data strictly as an offline fallback.
2. **Cache Sync**: Successful server responses should overwrite the local cache so future loads stay fresh.
3. **Graceful Degradation**: History consumers (e.g., `useAnalysis`) must handle records missing fields without throwing.
4. **Observability**: Add logging/error handling to detect when fallbacks occur, without spamming production logs.
5. **Backwards Compatibility**: Existing history files and local cache formats must continue to function after the change.
6. **Test Coverage**: Add unit coverage for the new fetch/sync flow and missing-field handling.

## Technical Approach
- Update `StorageService.getAnalyses()` to:
  - Attempt `/api/storage` (or specific history endpoint) with `useAPIFetch`/`fetchWithBaseUrl`.
  - On success, normalize/sort results, write them into local cache, and return.
  - On failure/network issue, fall back to `getAnalysesFromLocalStorage()` while logging a warning.
- Introduce a helper to merge or replace local cache atomically to prevent stale overrides.
- Enhance `useAnalysis.loadAnalyses()` (and `loadSavedAnalysis`) to:
  - Filter out records missing required fields or shim them with defaults.
  - Surface validation warnings to the console or UI if entries are skipped.
- Optionally migrate local cache once per load by comparing a checksum/timestamp from server data before writing.

## Implementation Steps
1. **StorageService Adjustments**
   - Modify `StorageService.getAnalyses()` to prefer server data, call a new `syncAnalysesToLocalStorage()` helper, and refine logging.
   - Ensure server fetch path handles empty arrays and non-200 responses with descriptive errors.
2. **Local Cache Utilities**
   - Add `setAnalysesToLocalStorage(analyses: SavedAnalysis[])` and reuse it after successful fetches.
   - Update any callers saving analyses so they leverage shared helpers.
3. **useAnalysis Hardening**
   - Update `loadAnalyses()` to await the new service behavior and keep reactive state in sync.
   - Guard `loadSavedAnalysis()` so it tolerates missing `jobPosting`/`resume` by short-circuiting with a toast/error message instead of throwing.
4. **Type & Validation Helpers**
   - Create a `validateSavedAnalysis()` utility (either in `useAnalysis` or `StorageService`) to ensure required fields exist before binding to UI.
5. **Testing**
   - Add/extend unit tests for `StorageService.getAnalyses()` to cover success, fallback, and sync scenarios.
   - Add composable tests (or component tests) confirming `useAnalysis` skips invalid entries and no longer crashes on selection.
6. **Documentation**
   - Update `docs/` or inline comments describing the new source-of-truth behavior and offline fallback expectations.

## Testing Strategy
- **Unit Tests**: Mock fetch responses for `StorageService` to verify server-first logic and cache syncing. Test fallback path by throwing network errors.
- **Composable Tests**: Use Vitest to mount `useAnalysis` with mocked StorageService responses to ensure state updates and error handling.
- **Manual QA**:
  1. Start dev server, confirm `/analyze` immediately shows latest server history without flashing older entries.
  2. Simulate offline (disable network or mock fetch failure) and confirm local cache still loads.
  3. Select a legacy entry lacking fields and verify UI shows a warning instead of breaking.

## Risks & Mitigation
- **Race Conditions**: Concurrent saves could overwrite cacheâ€”mitigate by always writing the full server payload atomically.
- **Silent Failures**: If server fetch silently fails, history might appear empty. Mitigate with user-facing notification/toast when fallback occurs.
- **Performance**: Large history files might slow down repeated syncs. Consider throttling or caching with timestamps if this emerges.

## Dependencies
- Existing `StorageService` fetch helpers (`fetchWithBaseUrl`).
- `/api/storage` endpoint returning `.data/analysis-history.json` contents.
- `useAnalysis` composable and related components consuming history data.
