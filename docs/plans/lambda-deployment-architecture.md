# Lambda + API Gateway + CloudFront Deployment Architecture

## Overview
Deploy Nuxt 3 SSR application using AWS Lambda for compute, API Gateway for routing, CloudFront for CDN, and S3 for static assets. This serverless architecture is cost-effective for intermittent usage patterns.

## Architecture Diagram

```
User Request
    ↓
CloudFront (CDN)
    ├─→ S3 (Static Assets: JS, CSS, images)
    └─→ API Gateway (Dynamic Routes)
            ↓
        Lambda (Nuxt SSR)
            ├─→ Aurora Serverless v1 (Database)
            ├─→ S3 (File Uploads)
            └─→ Firebase (Authentication)
```

## Component Breakdown

### 1. CloudFront (CDN)
**Purpose**: Global content delivery, caching, HTTPS termination

**Handles**:
- Static assets (cached at edge locations)
- HTML caching (configurable TTL)
- HTTPS/SSL certificates
- Custom domain routing
- Geographic distribution

**Configuration**:
- Origin 1: S3 bucket (static assets)
- Origin 2: API Gateway (dynamic content)
- Cache behaviors:
  - `/_nuxt/*` → S3 (long cache, immutable)
  - `/api/*` → API Gateway (no cache)
  - `/*` → API Gateway (short cache for SSR HTML)

### 2. S3 (Static Assets)
**Purpose**: Host static files generated by Nuxt build

**Contains**:
- JavaScript bundles (`/_nuxt/*.js`)
- CSS files (`/_nuxt/*.css`)
- Images, fonts, other static assets
- Source maps (optional)

**Configuration**:
- Public read access (via CloudFront only)
- Versioned file names (cache busting)
- Lifecycle policies (delete old versions)

### 3. API Gateway
**Purpose**: HTTP routing to Lambda, request/response transformation

**Routes**:
- `/api/*` → Lambda (API endpoints)
- `/*` → Lambda (SSR pages)

**Features**:
- REST API or HTTP API (HTTP API is cheaper)
- Request validation
- Rate limiting
- CORS configuration
- Custom domain mapping

### 4. Lambda (Nuxt SSR)
**Purpose**: Server-side rendering and API logic

**Configuration**:
- Runtime: Node.js 20.x
- Memory: 1024-2048 MB (adjust based on needs)
- Timeout: 30 seconds (API Gateway max)
- Environment variables: DATABASE_URL, S3_BUCKET, etc.
- VPC: Optional (needed for Aurora in VPC)

**Handles**:
- Nuxt SSR rendering
- API endpoints (`/api/*`)
- Database queries
- S3 operations
- Firebase authentication

### 5. Aurora Serverless v1 (Database)
**Purpose**: PostgreSQL database with auto-pause

**Features**:
- Auto-pauses after 5 minutes idle
- Auto-resumes in ~30 seconds
- pgvector support
- Automatic backups

**Connection**:
- Lambda connects via VPC (if Aurora in VPC)
- Or publicly accessible (with security group)
- Connection pooling recommended

### 6. S3 (File Uploads)
**Purpose**: Store user-uploaded files (resumes, etc.)

**Already configured** via existing CloudFormation template

### 7. Firebase (Authentication)
**Purpose**: User authentication and authorization

**Already integrated** in application

---

## Cost Breakdown

### Monthly Costs (Low Traffic: 1,000-5,000 page views)

| Service | Free Tier | Cost After Free Tier | Estimated Cost |
|---------|-----------|---------------------|----------------|
| **Lambda** | 1M requests, 400K GB-seconds | $0.20/1M requests + $0.0000166667/GB-second | $0-2 |
| **API Gateway** | 1M requests | $1.00/1M requests (HTTP API) | $0-1 |
| **CloudFront** | 1TB data transfer, 10M requests | $0.085/GB + $0.0075/10K requests | $0-2 |
| **S3 (static)** | 5GB storage, 20K GET requests | $0.023/GB + $0.0004/1K requests | $0-1 |
| **S3 (uploads)** | 5GB storage | $0.023/GB | $0-1 |
| **Aurora Serverless v1** | None | $0.06/hour + $0.10/GB-month storage | $2-16 |
| **Route 53** (optional) | None | $0.50/hosted zone + $0.40/1M queries | $0.50-1 |

**Total Estimated Cost**: $2-24/month
- **Minimum** (mostly idle): ~$2-5/month
- **Active development** (8 hrs/day): ~$18-24/month
- **Occasional demos** (4 hrs/month): ~$2-3/month

### Cost Comparison

| Architecture | Idle Cost | Active Cost | Best For |
|--------------|-----------|-------------|----------|
| **Lambda + CloudFront** | $2-5/month | $18-24/month | Intermittent usage |
| **App Runner** | $7-10/month | $50-100/month | Always-on apps |
| **EC2 t3.micro** | $8/month | $8/month | Predictable traffic |

---

## Deployment Strategy

### Phase 1: Infrastructure Setup
1. Create S3 bucket for static assets
2. Create Lambda function
3. Create API Gateway
4. Create CloudFront distribution
5. Configure IAM roles and policies

### Phase 2: Application Build
1. Build Nuxt for Lambda deployment
2. Package Lambda function
3. Upload static assets to S3
4. Deploy Lambda function

### Phase 3: Configuration
1. Configure environment variables
2. Set up VPC (if needed for Aurora)
3. Configure CloudFront cache behaviors
4. Set up custom domain (optional)

### Phase 4: Testing & Monitoring
1. Test SSR rendering
2. Test API endpoints
3. Verify database connectivity
4. Set up CloudWatch alarms
5. Monitor costs

---

## Nuxt 3 Lambda Adapter

### Build Configuration

Nuxt 3 has built-in support for AWS Lambda via the `aws-lambda` preset:

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    preset: 'aws-lambda',
    
    // Lambda-specific configuration
    awsLambda: {
      // Memory size (MB)
      memory: 1024,
      
      // Timeout (seconds, max 30 for API Gateway)
      timeout: 30,
      
      // Runtime
      runtime: 'nodejs20.x',
    },
    
    // Environment variables
    runtimeConfig: {
      public: {
        apiBase: process.env.API_BASE_URL,
      },
      // Private (server-only)
      databaseUrl: process.env.DATABASE_URL,
      awsRegion: process.env.AWS_REGION,
      s3Bucket: process.env.S3_BUCKET_NAME,
    },
  },
});
```

### Build Output

After running `npm run build`, Nuxt generates:
- `.output/server/` - Lambda function code
- `.output/public/` - Static assets for S3

### Lambda Handler

Nuxt automatically creates a Lambda handler at `.output/server/index.mjs`:

```javascript
// .output/server/index.mjs (generated by Nuxt)
export const handler = async (event, context) => {
  // Nuxt handles the request
  return await nitroApp.localFetch(event, context);
};
```

---

## CloudFormation Templates

### Template 1: S3 Static Assets Bucket

```yaml
# infra/cloudformation/static-assets-s3.yml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'S3 bucket for Nuxt static assets'

Parameters:
  EnvironmentName:
    Type: String
    Default: 'job-analyzer'

Resources:
  StaticAssetsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${EnvironmentName}-static-assets'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldVersions
            Status: Enabled
            NoncurrentVersionExpirationInDays: 30
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: job-posting-analyzer

  StaticAssetsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref StaticAssetsBucket
      PolicyDocument:
        Statement:
          - Sid: AllowCloudFrontAccess
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub '${StaticAssetsBucket.Arn}/*'
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}'

Outputs:
  BucketName:
    Value: !Ref StaticAssetsBucket
    Export:
      Name: !Sub '${EnvironmentName}-static-assets-bucket'
  
  BucketArn:
    Value: !GetAtt StaticAssetsBucket.Arn
    Export:
      Name: !Sub '${EnvironmentName}-static-assets-bucket-arn'
```

### Template 2: Lambda Function

```yaml
# infra/cloudformation/lambda-function.yml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'Lambda function for Nuxt SSR'

Parameters:
  EnvironmentName:
    Type: String
    Default: 'job-analyzer'
  
  LambdaCodeBucket:
    Type: String
    Description: 'S3 bucket containing Lambda deployment package'
  
  LambdaCodeKey:
    Type: String
    Description: 'S3 key for Lambda deployment package'
  
  DatabaseUrl:
    Type: String
    NoEcho: true
    Description: 'Aurora Serverless connection string'

Resources:
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${EnvironmentName}-lambda-execution-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Resource: !Sub 'arn:aws:s3:::${EnvironmentName}-*/*'
        - PolicyName: SecretsManagerAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${EnvironmentName}/*'

  NuxtLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${EnvironmentName}-nuxt-ssr'
      Runtime: nodejs20.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        S3Bucket: !Ref LambdaCodeBucket
        S3Key: !Ref LambdaCodeKey
      MemorySize: 1024
      Timeout: 30
      Environment:
        Variables:
          NODE_ENV: production
          DATABASE_URL: !Ref DatabaseUrl
          AWS_REGION: !Ref AWS::Region
          S3_BUCKET_NAME: !Sub '${EnvironmentName}-uploads'
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: job-posting-analyzer

  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${NuxtLambdaFunction}'
      RetentionInDays: 7

  LambdaVersion:
    Type: AWS::Lambda::Version
    Properties:
      FunctionName: !Ref NuxtLambdaFunction

  LambdaAlias:
    Type: AWS::Lambda::Alias
    Properties:
      FunctionName: !Ref NuxtLambdaFunction
      FunctionVersion: !GetAtt LambdaVersion.Version
      Name: live

Outputs:
  LambdaFunctionArn:
    Value: !GetAtt NuxtLambdaFunction.Arn
    Export:
      Name: !Sub '${EnvironmentName}-lambda-function-arn'
  
  LambdaFunctionName:
    Value: !Ref NuxtLambdaFunction
    Export:
      Name: !Sub '${EnvironmentName}-lambda-function-name'
```

### Template 3: API Gateway

```yaml
# infra/cloudformation/api-gateway.yml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'API Gateway for Lambda integration'

Parameters:
  EnvironmentName:
    Type: String
    Default: 'job-analyzer'
  
  LambdaFunctionArn:
    Type: String
    Description: 'ARN of the Lambda function'

Resources:
  HttpApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub '${EnvironmentName}-http-api'
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins:
          - '*'
        AllowMethods:
          - GET
          - POST
          - PUT
          - DELETE
          - OPTIONS
        AllowHeaders:
          - '*'
        MaxAge: 300

  LambdaIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref HttpApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Ref LambdaFunctionArn
      PayloadFormatVersion: '2.0'

  DefaultRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref HttpApi
      RouteKey: '$default'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref HttpApi
      StageName: '$default'
      AutoDeploy: true
      AccessLogSettings:
        DestinationArn: !GetAtt ApiLogGroup.Arn
        Format: '$context.requestId $context.error.message $context.error.messageString'

  ApiLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/apigateway/${EnvironmentName}-http-api'
      RetentionInDays: 7

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LambdaFunctionArn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${HttpApi}/*'

Outputs:
  ApiEndpoint:
    Value: !GetAtt HttpApi.ApiEndpoint
    Export:
      Name: !Sub '${EnvironmentName}-api-endpoint'
  
  ApiId:
    Value: !Ref HttpApi
    Export:
      Name: !Sub '${EnvironmentName}-api-id'
```

### Template 4: CloudFront Distribution

```yaml
# infra/cloudformation/cloudfront-distribution.yml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFront distribution for Nuxt application'

Parameters:
  EnvironmentName:
    Type: String
    Default: 'job-analyzer'
  
  StaticAssetsBucket:
    Type: String
    Description: 'S3 bucket for static assets'
  
  ApiGatewayEndpoint:
    Type: String
    Description: 'API Gateway endpoint (without https://)'

Resources:
  CloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub '${EnvironmentName}-oac'
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Comment: !Sub '${EnvironmentName} Nuxt application'
        DefaultRootObject: ''
        
        Origins:
          # Origin 1: S3 for static assets
          - Id: S3Origin
            DomainName: !Sub '${StaticAssetsBucket}.s3.${AWS::Region}.amazonaws.com'
            OriginAccessControlId: !Ref CloudFrontOriginAccessControl
            S3OriginConfig: {}
          
          # Origin 2: API Gateway for dynamic content
          - Id: ApiGatewayOrigin
            DomainName: !Ref ApiGatewayEndpoint
            CustomOriginConfig:
              HTTPSPort: 443
              OriginProtocolPolicy: https-only
              OriginSSLProtocols:
                - TLSv1.2
        
        DefaultCacheBehavior:
          # Default: Route to API Gateway (SSR)
          TargetOriginId: ApiGatewayOrigin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
            - PUT
            - POST
            - PATCH
            - DELETE
          CachedMethods:
            - GET
            - HEAD
          ForwardedValues:
            QueryString: true
            Cookies:
              Forward: all
            Headers:
              - Accept
              - Accept-Language
              - Authorization
              - CloudFront-Forwarded-Proto
              - Host
              - Origin
              - Referer
          MinTTL: 0
          DefaultTTL: 0
          MaxTTL: 31536000
          Compress: true
        
        CacheBehaviors:
          # Static assets from S3 (long cache)
          - PathPattern: '/_nuxt/*'
            TargetOriginId: S3Origin
            ViewerProtocolPolicy: redirect-to-https
            AllowedMethods:
              - GET
              - HEAD
            CachedMethods:
              - GET
              - HEAD
            ForwardedValues:
              QueryString: false
              Cookies:
                Forward: none
            MinTTL: 31536000
            DefaultTTL: 31536000
            MaxTTL: 31536000
            Compress: true
          
          # API routes (no cache)
          - PathPattern: '/api/*'
            TargetOriginId: ApiGatewayOrigin
            ViewerProtocolPolicy: redirect-to-https
            AllowedMethods:
              - GET
              - HEAD
              - OPTIONS
              - PUT
              - POST
              - PATCH
              - DELETE
            CachedMethods:
              - GET
              - HEAD
            ForwardedValues:
              QueryString: true
              Cookies:
                Forward: all
              Headers:
                - '*'
            MinTTL: 0
            DefaultTTL: 0
            MaxTTL: 0
            Compress: true
        
        PriceClass: PriceClass_100  # US, Canada, Europe
        ViewerCertificate:
          CloudFrontDefaultCertificate: true
          # For custom domain:
          # AcmCertificateArn: !Ref Certificate
          # SslSupportMethod: sni-only
          # MinimumProtocolVersion: TLSv1.2_2021

      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: job-posting-analyzer

Outputs:
  DistributionId:
    Value: !Ref CloudFrontDistribution
    Export:
      Name: !Sub '${EnvironmentName}-cloudfront-distribution-id'
  
  DistributionDomainName:
    Value: !GetAtt CloudFrontDistribution.DomainName
    Export:
      Name: !Sub '${EnvironmentName}-cloudfront-domain'
  
  DistributionUrl:
    Value: !Sub 'https://${CloudFrontDistribution.DomainName}'
    Description: 'CloudFront distribution URL'
```

---

## Deployment Scripts

### Script 1: Build and Package

```bash
#!/bin/bash
# scripts/deploy/build-lambda.sh

set -e

echo "Building Nuxt for Lambda..."
npm run build

echo "Packaging Lambda function..."
cd .output/server
zip -r ../../lambda-function.zip .
cd ../..

echo "Lambda package created: lambda-function.zip"
echo "Size: $(du -h lambda-function.zip | cut -f1)"
```

### Script 2: Deploy Static Assets

```bash
#!/bin/bash
# scripts/deploy/deploy-static-assets.sh

set -e

BUCKET_NAME="${ENVIRONMENT_NAME:-job-analyzer}-static-assets"
BUILD_DIR=".output/public"

echo "Deploying static assets to S3..."

# Sync static assets
aws s3 sync $BUILD_DIR s3://$BUCKET_NAME/ \
  --delete \
  --cache-control "public, max-age=31536000, immutable" \
  --exclude "*.html"

# Upload HTML with shorter cache
aws s3 sync $BUILD_DIR s3://$BUCKET_NAME/ \
  --cache-control "public, max-age=0, must-revalidate" \
  --exclude "*" \
  --include "*.html"

echo "Static assets deployed successfully"
```

### Script 3: Deploy Lambda

```bash
#!/bin/bash
# scripts/deploy/deploy-lambda.sh

set -e

FUNCTION_NAME="${ENVIRONMENT_NAME:-job-analyzer}-nuxt-ssr"
LAMBDA_PACKAGE="lambda-function.zip"

echo "Uploading Lambda function..."

aws lambda update-function-code \
  --function-name $FUNCTION_NAME \
  --zip-file fileb://$LAMBDA_PACKAGE

echo "Waiting for Lambda update to complete..."
aws lambda wait function-updated \
  --function-name $FUNCTION_NAME

echo "Lambda function deployed successfully"
```

### Script 4: Invalidate CloudFront Cache

```bash
#!/bin/bash
# scripts/deploy/invalidate-cloudfront.sh

set -e

DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
  --stack-name ${ENVIRONMENT_NAME:-job-analyzer}-cloudfront \
  --query 'Stacks[0].Outputs[?OutputKey==`DistributionId`].OutputValue' \
  --output text)

echo "Invalidating CloudFront cache..."

aws cloudfront create-invalidation \
  --distribution-id $DISTRIBUTION_ID \
  --paths "/*"

echo "CloudFront invalidation created"
```

### Script 5: Full Deployment

```bash
#!/bin/bash
# scripts/deploy/deploy-all.sh

set -e

echo "=== Full Deployment ==="

# Build and package
./scripts/deploy/build-lambda.sh

# Deploy static assets
./scripts/deploy/deploy-static-assets.sh

# Deploy Lambda
./scripts/deploy/deploy-lambda.sh

# Invalidate CloudFront
./scripts/deploy/invalidate-cloudfront.sh

echo "=== Deployment Complete ==="
echo "Application URL: https://$(aws cloudformation describe-stacks \
  --stack-name ${ENVIRONMENT_NAME:-job-analyzer}-cloudfront \
  --query 'Stacks[0].Outputs[?OutputKey==`DistributionDomainName`].OutputValue' \
  --output text)"
```

---

## Cold Start Optimization

### Lambda Configuration
```yaml
# Provisioned Concurrency (optional, costs extra)
ProvisionedConcurrencyConfig:
  ProvisionedConcurrentExecutions: 1  # Keep 1 instance warm
```

### Application-Level Optimization
```typescript
// server/middleware/warmup.ts
export default defineEventHandler((event) => {
  // Handle warmup requests from CloudWatch Events
  if (event.headers.get('x-warmup') === 'true') {
    return { status: 'warm' };
  }
});
```

### CloudWatch Event for Warmup
```yaml
# Keep Lambda warm (optional, costs ~$0.10/month)
WarmupRule:
  Type: AWS::Events::Rule
  Properties:
    ScheduleExpression: 'rate(5 minutes)'
    State: ENABLED
    Targets:
      - Arn: !GetAtt NuxtLambdaFunction.Arn
        Id: WarmupTarget
        Input: '{"headers":{"x-warmup":"true"}}'
```

---

## Monitoring and Logging

### CloudWatch Dashboards
- Lambda invocations, duration, errors
- API Gateway requests, latency, 4xx/5xx errors
- CloudFront requests, cache hit ratio
- Aurora connections, query duration

### Recommended Alarms
```yaml
# Lambda errors
LambdaErrorAlarm:
  Type: AWS::CloudWatch::Alarm
  Properties:
    AlarmName: !Sub '${EnvironmentName}-lambda-errors'
    MetricName: Errors
    Namespace: AWS/Lambda
    Statistic: Sum
    Period: 300
    EvaluationPeriods: 1
    Threshold: 5
    ComparisonOperator: GreaterThanThreshold

# API Gateway 5xx errors
ApiGateway5xxAlarm:
  Type: AWS::CloudWatch::Alarm
  Properties:
    AlarmName: !Sub '${EnvironmentName}-api-5xx-errors'
    MetricName: 5XXError
    Namespace: AWS/ApiGateway
    Statistic: Sum
    Period: 300
    EvaluationPeriods: 1
    Threshold: 10
    ComparisonOperator: GreaterThanThreshold
```

---

## Testing Strategy

### Local Testing
```bash
# Test Lambda function locally
npm run build
cd .output/server
node index.mjs

# Or use AWS SAM
sam local start-api
```

### Integration Testing
```bash
# Test deployed API
curl https://your-cloudfront-domain.cloudfront.net/

# Test API endpoints
curl https://your-cloudfront-domain.cloudfront.net/api/resumes

# Test static assets
curl https://your-cloudfront-domain.cloudfront.net/_nuxt/entry.js
```

### Load Testing
```bash
# Use Apache Bench
ab -n 1000 -c 10 https://your-cloudfront-domain.cloudfront.net/

# Or use Artillery
artillery quick --count 100 --num 10 https://your-cloudfront-domain.cloudfront.net/
```

---

## Security Considerations

### IAM Roles
- Lambda execution role: Least privilege access
- CloudFront OAC: S3 access only via CloudFront
- API Gateway: No public access to Lambda

### Environment Variables
- Store secrets in AWS Secrets Manager
- Reference in Lambda environment variables
- Rotate credentials regularly

### Network Security
- Aurora in private subnet (optional)
- Lambda in VPC (if Aurora in VPC)
- Security groups: Restrict access

### HTTPS
- CloudFront enforces HTTPS
- API Gateway uses HTTPS
- Custom domain with ACM certificate

---

## Rollback Strategy

### Lambda Versions
```bash
# Rollback to previous version
aws lambda update-alias \
  --function-name job-analyzer-nuxt-ssr \
  --name live \
  --function-version <previous-version>
```

### CloudFront Invalidation
```bash
# If bad deployment, invalidate and redeploy
aws cloudfront create-invalidation \
  --distribution-id <distribution-id> \
  --paths "/*"
```

### Database Rollback
- Aurora automatic backups (point-in-time recovery)
- Manual snapshots before major changes

---

## Next Steps

1. **Review architecture** and cost estimates
2. **Create CloudFormation templates** for each component
3. **Set up deployment scripts** for automation
4. **Test locally** with SAM or similar
5. **Deploy to AWS** in stages (Lambda → API Gateway → CloudFront)
6. **Monitor costs** for first month
7. **Optimize** based on actual usage patterns

---

## Comparison: Lambda vs App Runner

| Feature | Lambda + CloudFront | App Runner |
|---------|-------------------|------------|
| **Idle Cost** | $2-5/month | $7-10/month |
| **Active Cost** | $18-24/month | $50-100/month |
| **Cold Start** | 1-3 seconds | N/A (always warm) |
| **Scaling** | Automatic, instant | Automatic, slower |
| **Complexity** | Higher (more components) | Lower (single service) |
| **Best For** | Intermittent usage | Always-on apps |

**Recommendation**: Lambda + CloudFront for your use case (intermittent demos, cost-conscious)
