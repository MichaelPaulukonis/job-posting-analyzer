# 20.authentication.md

## Problem Statement

Add a secure and flexible authentication system using Firebase to support email/password and Google (OAuth) sign-in for the Job Posting Analyzer. Authentication will be implemented following the Driftboard auth strategy, adapted to Nuxt 3 and our codebase structure.

## Goals & Requirements

- Provide email/password and Google sign-in flows using Firebase Authentication.
- Implement server-side verification (Firebase Admin) for server API endpoints.
- Provide composables and services for UI-level auth (login/logout, signup, session state, user profile).
- Provide route protection middleware for pages that require authentication.
- Support localStorage/session persistence and token refresh handling.
- Provide tests (unit and e2e) validating login flows and protected endpoints.
- Document environment variables and developer setup in README and docs.

## Technical Approach

- Client: Use Firebase SDK in the browser. Create a `firebase-client` plugin script to initialize Firebase using runtime environment variables (via Nuxt `useRuntimeConfig`). Expose a composable (`useAuth`) to manage auth state. Use `onAuthStateChanged` to keep `currentUser` updated and a small local token refresher.

- Server: Use Firebase Admin SDK in server endpoints to validate ID tokens when calling protected APIs. Create middleware for API endpoints that verifies the token and injects a minimal `user` object into event context.

- Services: Create `services/AuthService.ts` and `services/FirebaseAuthService.ts` to encapsulate the Firebase implementation details and provide an implementation of an `AuthService` interface. This fits the project's service architecture.

- UI: Construct pages in `pages/login.vue` and `pages/signup.vue`. Add a header adaptation that shows login status and a logout button. Prefer reusing patterns from the `components/input` and `layout` folders.

- Configuration & Secrets: Use Nuxt runtime config and `.env` to store Firebase config and the Admin SDK credentials (for local dev use service account JSON, in production use secrets manager). Document the steps to retrieve Firebase config.

- Testing: Add unit tests for composable functions and services (`tests/services/auth/`, `tests/composables/`). Add Playwright tests for login/signup and a protected route.

## Acceptance Criteria

- Users can sign up and sign in with Firebase email/password and Google OAuth.
- Protected pages redirect unauthenticated users to the login page.
- Protected server API endpoints properly reject requests with invalid or absent tokens.
- Auth state persists across page reloads (within session) and token refresh works.
- Tests and docs updated accordingly.

## Implementation Steps / Subtasks

- 20.1: Create the plan file (this file). Documented.
- 20.2: Add environment variable structure and instructions to README and `nuxt.config.ts` to enable runtime config for Firebase.
- 20.3: Create plugin `plugins/firebase.client.ts` to initialize Firebase client SDK.
- 20.4: Implement `composables/useAuth.ts` to expose `user`, `signIn`, `signUp`, `signOut`, `getIdToken`, and `isAuthenticated` state.
- 20.5: Create `services/FirebaseAuthService.ts` implementing `AuthService` interface, wrapping the client SDK operations.
- 20.6: Implement server-side verification `server/api/auth/verify` and `server/api/auth/session` and middleware to protect routes.
- 20.7: Implement UI pages (`pages/login.vue`, `pages/signup.vue`) and a `components/AuthBar` for header UI.
- 20.8: Add middleware `middleware/auth.ts` for page guards and Nuxt route meta usage (e.g., `default.vue` or `analyze` pages), and update route meta for protected pages.
- 20.9: Add unit tests and Playwright e2e tests for login, signup, and protected routes.
- 20.10: Add docs (`docs/auth.md`) summarizing setup and troubleshooting.

## Risks & Mitigations

- Managing Admin credentials in local dev: Use `FIREBASE_SERVICE_ACCOUNT` JSON or a local file and document steps in the plan and docs. If service account not available, tests should skip server ACL flows or use mocked service.
- Token handling: Use Firebase's `onAuthStateChanged` and standard token refresh flows to avoid manual refresh handling. Document if additional refresh logic needed.
- Cross-origin and cookie session tradeoffs: We'll use ID tokens passed via Bearer header for API protection, avoid cookies, which simplifies CORS handling during API calls.

## Dependencies

- Nuxt runtime config: `nuxt.config.ts` must provide Firebase runtime config.
- Add `firebase` and `firebase-admin` as dependencies (NPM) and type definitions.
- Update `package.json` and `tsconfig.json` to include types if necessary.

## Developer Notes

- Follow driftboard's auth approach (with ID token verification on the server and onAuthStateChanged on client) and adapt to Nuxt 3.
- Follow established Service interface patterns (see `services/` directory for similar services) so the auth logic is swappable if needed.

## Next Steps
- Create the scaffolding files, environment variables, and plugin skeletons. 
- Start implementing the `composables/useAuth.ts` and `services/FirebaseAuthService.ts` while running small unit tests.

---

> This plan file follows the project's Plan-File Requirement from `.github/copilot-instructions.md`.
